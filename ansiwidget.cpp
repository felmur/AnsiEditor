#include "ansiwidget.h"
#include <QFontDatabase>
#include <QPainter>
#include <QKeyEvent>
#include <QMouseEvent>
#include "qcodepage437codec.h"
#include "palette.h"
#include "toolbox.h"
#include <QFile>
#include <QDate>


extern Palette *pal;
extern ToolBox *tb;

QCodePage437Codec *qp=nullptr;

#include "sauce.h"
extern QString eof;
extern struct _sauce sauce;


AnsiWidget::AnsiWidget(QWidget *parent)
    : QWidget{parent}
{
    QFontDatabase::addApplicationFont(":/font/hack");
    QFont font = QFont(fontname,fontsize,500);
    QFontMetrics fm(font);
    ha = fm.horizontalAdvance(QString(" "));
    setFont(font);

    setGeometry(0,0,cols*ha+2*padding, rows*(fontsize+interline)+2*padding);

    buf = (char *)malloc(rows*cols);
    attrs = (char *)malloc(rows*cols);
    if (!buf or !attrs) {
        if (DEBUG) cout << "ERROR: cannot allocate memory" << endl;
        exit(1);
    }
    clear();

    qp = new QCodePage437Codec();

    timer1 = new QTimer(this);
    timer1->setInterval(500);
    timer1->start();
    connect(timer1, SIGNAL(timeout()),this, SLOT(timer1timeout()));

    QPalette pal = QPalette();
    pal.setColor(QPalette::Window, Qt::black);
    setAutoFillBackground(true);
    setPalette(pal);

    rubber = new QRubberBand(QRubberBand::Rectangle, this);
    QPalette pal2;
    pal2.setBrush(QPalette::Highlight, QBrush(Qt::yellow));
    rubber->setPalette(pal2);

    installEventFilter(this);

    memset((void *)&sauce, 0, sizeof(sauce));
    memcpy(sauce.ID,"SAUCE",5);
    memcpy(sauce.version,"00",2);
    memset(sauce.title,32,35);
    memcpy(sauce.title,"Generated by AnsiEditor",23);
    memset(sauce.author,32,20);
    memset(sauce.group,32,20);
    QString s = QDate::currentDate().toString("yyyyMMdd");
    memcpy(sauce.date,TC(s),8);
    memcpy(sauce.tinfos,"IBM VGA",7); // copied from other ansi editor
    sauce.filetype = (uint8_t) 1;
    sauce.datatype = (uint8_t) 1;
    sauce.comments = (uint8_t) 0;
    sauce.tinfo1 = (uint16_t) cols+2;  // colonne, il +2 serve per rendere l'ansi compatibile con pablodraw e moebius (??)
    sauce.tinfo2 = (uint16_t) 25;  // righe
    sauce.flags = 18;   // copied from other ansi editor, see ansiflags in html SauceInfo.html
    show();
}

AnsiWidget::~AnsiWidget()
{
    if (buf) free(buf);
    if (attrs) free(attrs);
}

void AnsiWidget::parseTxt(char *str){
    QString _str;
    QString ln,p;
    QString cmd,par;
    QByteArray dat;
    uint i,j,offs;


    if (!strlen(str)) return;

    _str = str;
    if (_str.startsWith(eof+"COMNT") || _str.startsWith(eof+"SAUCE00")) {
        return;
    }


    for (i=0; i<strlen(str); i++) {
        if (str[i] != 13) {
            ln.append(str[i]);
        }
    }
    QStringList parts = ln.split(csi);
    foreach(auto pt, parts){
        if (pt != parts[0]) {
            if (parts.length()>1) {
                cmd.clear();
                par.clear();
                dat.clear();
                if (DEBUG) cout << "csi PART: '" << TC(pt) << "'" << endl;
                p = pt.left(14);
                for (i=0; i<p.size(); i++){
                    foreach(auto c, cmds) {
                        if (*(TC(p)+i) == c.at(0)) {
                            cmd = c;
                            par = pt.left(i);
                            p = pt.right(pt.length()-i-1);
                            dat = StoQ(p);
                            break;
                        }
                    }
                    if (cmd != "") break;
                }
                if (cmd != "") {
                    if (DEBUG) cout << "CMD,PAR,DAT: " << TC(cmd) << "," << TC(par) << ",'" << dat.data() << "'" << endl;
                    // TODO riconoscimento comandi ANSI
                    switch(cmd.at(0).toLatin1()) {
                    case 'A':
                        if (par == "") par="1";
                        riga -= par.toInt();
                        if (riga<0) riga=0;
                        break;

                    case 'B':
                        if (par == "") par="1";
                        riga += par.toInt();
                        if (riga>rows-1) riga=rows-1;
                        break;

                    case 'C':
                        if (par == "") par="1";
                        colo += par.toInt();
                        if (colo > cols-1) colo=cols-1;
                        break;

                    case 'D':
                        if (par == "") par="1";
                        colo -= par.toInt();
                        if (colo<0) colo = 0;
                        break;

                    case 'H':
                    case 'f':
                        if (par == ""){
                            riga = 0;
                            colo = 0;
                        }
                        else {
                            riga=0;
                            colo=0;
                            QStringList parpart = par.split(';');
                            if (parpart.length()==1){
                                riga=parpart[0].toInt()-1;
                                colo=0;
                            }
                            else if (parpart.length()>=2){
                                riga = parpart[0].toInt()-1;
                                colo = parpart[1].toInt()-1;
                            }
                        }
                        break;

                    case 'J':
                        if (par=="2" && shw2J) {
                            if (buf) memset(buf,32,rows*cols);
                            if (attrs) memset(attrs,0,rows*cols);
                            repaint();
                        }
                        break;

                    case 'm':
                        if (par != ""){
                            QStringList parpart = par.split(";");
                            foreach (QString s, parpart) {
                                i = s.toInt();
                                if (i >=30 && i <=37){
                                    fg = i-30;
                                    if (bright) {
                                        if (fg<8) fg+=8;
                                    }
                                }
                                else if (i >=40 && i <=47) bg = i-40;
                                else if (i == 39) fg = 7;
                                else if (i == 49) bg = 0;
                                else if (i == 0) {
                                    fg = 7;
                                    bg = 0;
                                    bright = false;
                                    blink = false;
                                }
                                if (i == 5) {
                                    blink = true;
                                    //timer1->start();
                                }
                                else if (i == 1) {
                                    bright=true;
                                    if (fg<8) fg+=8;
                                }
                                else if (i == 22){
                                    bright=false;
                                    if (fg>7) fg-=8;
                                }
                                else if (i == 25){
                                    blink = false;
                                    //timer1->stop();
                                }
                            }
                        }
                        break;
                    case 's':
                        sriga = riga;
                        scolo = colo;
                        break;
                    case 'u':
                        riga = sriga;
                        colo = scolo;
                        break;
                    }
                    if (dat.length()) {
                        offs = riga*cols+colo;
                        if (DEBUG) cout << "OFFS: " << offs << ", " << riga << ", " << colo << endl;
                        if (offs>(uint) rows*cols){
                            if (DEBUG) cout << "File is too big: max=" << rows*cols << ", offset required=" <<  offs << endl;
                        }
                        else {
                            j = (uint8_t) ((fg & 0x0f) << 4) + (bg & 0x07);
                            if (blink) j |= 8;
                            while (colo+dat.length()>(uint)cols) {
                                if (DEBUG) cout << "PRIMO:" << colo << " " << dat.length() << endl;
                                offs = riga*cols+colo;
                                QByteArray w = dat.left(cols-colo);
                                dat = dat.right(dat.length() - w.length());
                                for(i=0; i<w.length(); i++) {
                                    *(buf+offs+i)=(uint8_t)w.at(i);
                                    *(attrs+offs+i)=j;
                                }
                                colo = 0;
                                riga++;
                            }
                            offs = riga*cols+colo;
                            for(i=0; i<dat.length(); i++) {
                                *(buf+offs+i)=(uint8_t)dat.at(i);
                                *(attrs+offs+i)=j;
                                colo ++;
                            }
                        }
                   }
                }
                else {
                    if (DEBUG) cout << "No known CSI command in this CSI-PART" << endl;
                    dat = StoQ(pt);
                    if (dat.length()) {
                        offs = riga*cols+colo;
                        if (offs>(uint)rows*cols){
                            if (DEBUG) cout << "File is too big: max=" << rows*cols << ", offset required=" <<  offs << endl;
                        }
                        else {
                            j = (uint8_t) ((fg & 0x0f) << 4) + (bg & 0x07);
                            if (blink) j |= 8;
                            while (colo+dat.length()>(uint)cols) {
                                offs = riga*cols+colo;
                                if (DEBUG) cout << "SECONDO:" << colo << " " << dat.length() << endl;
                                QByteArray w = dat.left(cols-colo);
                                dat = dat.right(dat.length() - w.length());
                                for(i=0; i<w.length(); i++) {
                                    *(buf+offs+i)=(uint8_t)w.at(i);
                                    *(attrs+offs+i)=j;
                                }
                                colo = 0;
                                riga++;
                            }
                            offs = riga*cols+colo;
                            for(i=0; i<dat.length(); i++) {
                                *(buf+offs+i)=(uint8_t)dat.at(i);
                                *(attrs+offs+i)=j;
                                colo ++;
                            }
                        }
                    }
                }
            }
        }
        else {
            dat = StoQ(pt);
            if (dat.length()) {
                offs = riga*cols+colo;
                if (offs>(uint)rows*cols){
                    if (DEBUG) cout << "File is too big: max=" << rows*cols << ", offset required=" <<  offs << endl;
                }
                else {
                    j = (uint8_t) ((fg & 0x0f) << 4) + (bg & 0x07);
                    if (blink) j |= 8;
                    while (colo+dat.length()>(uint)cols) {
                        if (DEBUG) cout << "TERZO:" << colo << " " << dat.length() << endl;
                        QByteArray w = dat.left(cols-colo);
                        dat = dat.right(dat.length() - w.length());
                        for(i=0; i<w.length(); i++) {
                            *(buf+offs+i)=(uint8_t)w.at(i);
                            *(attrs+offs+i)=j;
                        }
                        colo = 0;
                        riga++;
                    }
                    offs = riga*cols+colo;
                    for(i=0; i<dat.length(); i++) {
                        *(buf+offs+i)=(uint8_t)dat.at(i);
                        *(attrs+offs+i)=j;
                        colo ++;
                    }
                }
            }
        }
    }
    riga++;
    colo=0;
}

void AnsiWidget::clear()
{
    if (buf) memset(buf,32,rows*cols);
    if (attrs) memset(attrs,0,rows*cols);
    riga=0;
    colo=0;
    fg=7;
    bg=0;
    csrow = 0;
    cscol = 0;
    unDo.clear();
    emit csrRowChanged(csrow);
    setFocus();
}


void AnsiWidget::paintEvent(QPaintEvent *e)
{
    (void) e;
    int ffg=2, bbg=7;
    int i,j,k;

    QPainter painter(this);

    char t[2];
    t[1]=0;
    for (i=0; i<rows; i++){
        for(j=0; j<cols; j++){
            int offs = i*cols+j;
            t[0]=*(buf+offs);
            k = (uint8_t)attrs[offs];
            ffg=(uint8_t)k >> 4;
            QFont font = QFont(fontname,fontsize,500);
            painter.setFont(font);
            if (ffg>7){
                font.setBold(true);
                painter.setFont(font);
            }
            bbg=(uint8_t)k & 0x07;
            painter.fillRect(j*ha+padding,i*(fontsize+interline)+padding-2,ha,fontsize+interline+2,colors[bbg]);
            painter.setPen(colors[ffg]);
            if ((k&8) && blinkst) painter.setPen(colors[bbg]);
            painter.drawText(j*ha+padding,fontsize+i*(fontsize+interline)+padding,qp->toUnicode(t));
        }
    }
    painter.fillRect(cscol*ha+padding, csrow*(fontsize+interline)+padding-2, ha, fontsize+interline+2,colors[16]);
    emit repaintDone();
}

uint AnsiWidget::getFontsize() const
{
    return fontsize;
}

uint AnsiWidget::getInterline() const
{
    return interline;
}

bool AnsiWidget::saveFile(QString filename)
{
    int fg, bg;
    char val, oval;
    int i,j,r,offs;
    uint32_t size;
    char t[2], l[cols+1];
    bool blk=false;

    QString a;

    // determina la prima riga non vuota, partendo dalla fine del buffer
    r=-1;
    for (i=rows-1; i>=0; i--){
        for (j=cols-1; j>=0; j--) {
            offs = i*cols+j;
            if (*(buf+offs)!=32 && *(buf+offs)!=0) {
                r = i+1;
                break;
            }
        }
        if (r>=0) break;
    }

    // routine di save vera e propria
    oval=-1;
    t[1]=0;
    size = 0;
    QFile f(filename);
    if (f.open(QFile::WriteOnly)){
        a=csi+"H"+csi+"2J"+csi+"0m";
        f.write(TC(a));
        size+=a.length();
        for (i=0; i<r; i++){
            offs = i*cols;
            memcpy(l,(attrs+offs),cols);
            l[cols]=0;
            for (j=0; j<cols; j++) {
                val=l[j];
                if (val != oval) {
                    a=csi;
                    if (!(val&8) && blk) {
                        a += ";0";
                        blk=false;
                    }
                    fg=(uint8_t)val >> 4;
                    if (fg>7) {
                        a += "1;";
                        fg -= 8;
                    }
                    else {
                        a+="0;";
                    }
                    bg=(uint8_t)val & 0x07;
                    a += QString::number(bg+40)+";";
                    a += QString::number(fg+30);
                    if (val&8) {
                        a += ";5";
                        blk=true;
                    }
                    a += "m";
                    f.write(TC(a));
                    size+=a.length();
                    oval = val;
                }
                t[0]=*(buf+offs+j);
                f.write(t);
                size+=1;
            }
            f.write("\r\n");
            size+=2;
        }
        f.write(TC(csi));
        f.write("0m\n");
        size+=5;
        sauce.tinfo2 = (uint16_t) r+1;
        sauce.size = (uint32_t) size;
        f.write(TC(eof));
        f.write((char *)&sauce,sizeof(sauce));
        f.close();
    }
    return true;
}

bool AnsiWidget::applicateUnDo()
{
    uint8_t vt,va;
    int offs,i,k;
    if (DEBUG) cout << "UndoPTR " << unDoPtr << endl;
    if (unDoPtr){
        k = unDo[unDoPtr-1].op;
        for (i=1; i<=k; i++) {
            offs = unDo[unDoPtr-i].offs;
            vt = unDo[unDoPtr-i].txtval;
            va = unDo[unDoPtr-i].attrsval;
            *(buf+offs) = vt;
            *(attrs+offs) = va;
            unDo.removeAt(unDoPtr-i);
        }
        unDoPtr-=k;
        repaint();
        return true;
    }
    return false;
}

uint AnsiWidget::getPadding() const
{
    return padding;
}

uint AnsiWidget::getRows() const
{
    return rows;
}

uint AnsiWidget::getCols() const
{
    return cols;
}

uint AnsiWidget::getHa() const
{
    return ha;
}

QByteArray AnsiWidget::StoQ(QString txt)
{
    QByteArray ret;
    int j;
    for(j=0; j<txt.length(); j++) {
        ret.append(txt.at(j).cell());
    }
    return ret;
}

int AnsiWidget::getCsrow() const
{
    return csrow;
}

int AnsiWidget::getCscol() const
{
    return cscol;
}

void AnsiWidget::timer1timeout()
{
    blinkst = !blinkst;
    repaint();
}

void AnsiWidget::cbBlinkChanged(int state)
{
    blinkwrt = false;
    if (state > 0) blinkwrt = true;
    setFocus();
}

void AnsiWidget::charClick(int val)
{
    int i;
    int offs = csrow*cols+cscol;
    int ffg,bbg;
    // UNDO stuff
    _unDo u;
    u.offs = offs;
    u.txtval = *(buf+offs);
    u.attrsval = *(attrs+offs);
    u.op = 1;
    unDo.append(u);
    unDoPtr++;
    //
    *(buf+offs) = (uint8_t) val;
    QList<int> c = pal->getColors();
    ffg = c[0];
    bbg = c[1];
    i = (uint8_t) ((ffg & 0x0f) << 4) + (bbg & 0x07);
    if (blinkwrt) i |= 8;
    *(attrs+offs) = (uint8_t) i;
    cscol++;
    if (cscol>=cols) {
        csrow++;
        if (csrow>=rows) {
            csrow=rows-1;
            cscol=79;
        }
        else {
            cscol=0;
            emit csrRowChanged(csrow);
        }
    }
    repaint();
    emit documentModified();
}

bool AnsiWidget::eventFilter(QObject *obj, QEvent *event)
{
    QKeyEvent *keyEvent;
    int key;

    if (event->type() == QEvent::KeyPress) {
        keyEvent = (QKeyEvent*)(event);
        key = keyEvent->key();
        if (key >=32 && key<127) {
            if ((key>=65 && key<=90) && keyEvent->modifiers()==Qt::NoModifier) key+=32;
            charClick(key);
        }
        if (keyEvent->modifiers() != Qt::ControlModifier) {
            cfin=0;
            rfin=0;
            rubber->setGeometry(0,0,0,0);
        }
        switch(key) {
        case Qt::Key_Down:
            csrow++;
            if (csrow>=rows) csrow=rows-1;
            emit csrRowChanged(csrow);
            break;
        case Qt::Key_Up:
            csrow--;
            if (csrow<0) csrow=0;
            emit csrRowChanged(csrow);
            break;
        case Qt::Key_Right:
            cscol++;
            if (cscol>=cols) {
                csrow++;
                if (csrow>=rows) {
                    csrow=rows-1;
                    cscol=79;
                }
                else {
                    cscol=0;
                    emit csrRowChanged(csrow);
                }
            }
            break;
        case Qt::Key_Left:
            cscol--;
            if (cscol<0) {
                csrow--;
                if (csrow<0) {
                    csrow=0;
                    cscol=0;
                }
                else {
                    cscol=79;
                    emit csrRowChanged(csrow);
                }
            }
            break;
        case Qt::Key_Home:
            cscol = 0;
            csrow = 0;
            break;
        case Qt::Key_Return:
            csrow++;
            if (csrow>=rows) {
                csrow = rows-1;
            }
            else {
                cscol = 0;
            }
            emit csrRowChanged(csrow);
            break;

        case Qt::Key_PageDown:
            csrow+=10;
            if (csrow>=rows){
                csrow = rows-1;
            }
            emit csrRowChanged(csrow);
            break;
        case Qt::Key_PageUp:
            csrow-=10;
            if (csrow<0){
                csrow = 0;
            }
            emit csrRowChanged(csrow);
            break;

        case Qt::Key_Backspace:
            if (cscol>0){
                cscol--;
                *(buf+csrow*cols+cscol)=32;
            }
            break;
        case Qt::Key_Delete:
            *(buf+csrow*cols+cscol)=32;
            break;
        }
        repaint();
        return true;
    }
    else {
        return false;
    }
    // pass the event on to the parent class
    return AnsiWidget::eventFilter(obj, event);
}


bool AnsiWidget::removeLine()
{
    bool ret = false;
    if (csrow < rows-1) {
        for (int i=(csrow+1)*cols; i<rows*cols; i++){
            *(buf+i-cols) = *(buf+i);
            *(attrs+i-cols) = *(attrs+i);
        }
        ret = true;
        emit documentModified();
    }
    return ret;
}

void AnsiWidget::mousePressEvent(QMouseEvent *e)
{
    cscol = (e->pos().x()-padding)/ha;
    csrow = (e->pos().y()-padding)/(fontsize+interline);
    if (tb->tbstate == ToolBox::PICK_ON) {
        int offs=csrow*cols+cscol;
        uint8_t v=*(attrs+offs);
        emit attrsPicked(v);
    }

    rubber->setGeometry(0,0,0,0);
    cfin=0;
    rfin=0;
    rubber->show();
    repaint();
}

void AnsiWidget::mouseMoveEvent(QMouseEvent *e)
{
    cfin = (e->pos().x()-padding)/ha;
    rfin = (e->pos().y()-padding)/(fontsize+interline);
    rubber->setGeometry(cscol*ha+padding, csrow*(fontsize+interline)+padding-2, (cfin-cscol)*ha,(rfin-csrow)*(fontsize+interline)+fontsize+interline+2);
}

void AnsiWidget::mouseReleaseEvent(QMouseEvent *e)
{
    (void) e;
    int offs,k,op;
    if (tb->tbstate == ToolBox::SQUARE_ON || tb->tbstate == ToolBox::SQUAREFILLED_ON) {
        rubber->setGeometry(0,0,0,0);
        QList<int> c = pal->getColors();
        int f = c[0];
        int b = c[1];
        op = 1;
        if (cfin > cscol && rfin>=csrow) {
            for (int i=csrow; i<=rfin; i++){
                for(int j=cscol; j<cfin; j++) {
                    offs=i*cols+j;
                    if(i>csrow && i<rfin && tb->tbstate==ToolBox::SQUARE_ON) {
                        if (j==cscol || j==cfin-1) {
                            // UNDO stuff
                            _unDo u;
                            u.offs = offs;
                            u.txtval = *(buf+offs);
                            u.attrsval = *(attrs+offs);
                            u.op = op;
                            unDo.append(u);
                            unDoPtr++;
                            op++;
                            //
                            *(buf+offs) = 0xdb;
                            k = (uint8_t) ((f & 0x0f) << 4) + (b & 0x07);
                            if (blinkwrt) k |= 8;
                            *(attrs+offs) = (uint8_t) k;
                        }
                    }
                    else {
                        // UNDO stuff
                        _unDo u;
                        u.offs = offs;
                        u.txtval = *(buf+offs);
                        u.attrsval = *(attrs+offs);
                        u.op = op;
                        unDo.append(u);
                        unDoPtr++;
                        op++;
                        //
                        *(buf+offs) = 0xdb;
                        k = (uint8_t) ((f & 0x0f) << 4) + (b & 0x07);
                        if (blinkwrt) k |= 8;
                        *(attrs+offs) = (uint8_t) k;
                    }
                }
            }
        }
        emit documentModified();
    }
    repaint();
}

QString AnsiWidget::getSelection(bool cut)
{
    QString ret="";
    int offs,op;
    char b,a;
    if (cfin > cscol && rfin>=csrow) {
        op=1;
        paste.pasteattrs.clear();
        paste.pastetxt.clear();
        for (int i=csrow; i<=rfin; i++){
            for(int j=cscol; j<cfin; j++) {
                offs=i*cols+j;
                b=*(buf+offs);
                a=*(attrs+offs);
                ret.append(b);
                paste.pastetxt.append(b);
                paste.pasteattrs.append(a);
                if (cut){
                    // UNDO stuff
                    _unDo u;
                    u.offs = offs;
                    u.txtval = *(buf+offs);
                    u.attrsval = *(attrs+offs);
                    u.op = op;
                    unDo.append(u);
                    unDoPtr++;
                    op++;
                    //
                    *(buf+offs)=32;
                    *(attrs+offs)=0;
                    emit documentModified();
                }
            }
            ret.append("\n");
            paste.pastetxt.append('\x00');
        }
    }
    cfin=0;
    rfin=0;
    rubber->setGeometry(0,0,0,0);
    return ret;
}

void AnsiWidget::ansiPaste()
{
    int offs,i,op,k;
    QList<QByteArray> lines;
    if (paste.pastetxt.length()){
        op = 1;
        offs=csrow*cols+cscol;
        lines = paste.pastetxt.split('\x00');
        k=0;
        foreach(auto l, lines){
            i=0;
            foreach(auto c, l){
                // UNDO stuff
                _unDo u;
                u.offs = offs+i;
                u.txtval = *(buf+offs+i);
                u.attrsval = *(attrs+offs+i);
                u.op = op;
                unDo.append(u);
                unDoPtr++;
                op++;
                //
                *(buf+offs+i) = c;
                *(attrs+offs+i) = paste.pasteattrs.at(k);
                i++;
                k++;
            }
            offs+=cols;
        }
        emit documentModified();
    }
}

bool AnsiWidget::getShw2J() const
{
    return shw2J;
}

void AnsiWidget::setShw2J(bool newShw2J)
{
    shw2J = newShw2J;
}

void AnsiWidget::applyAttrs()
{
    int op, offs;
    uint ffg, bbg, a;

    QList<int> c = pal->getColors();
    ffg = c[0];
    bbg = c[1];

    if (cfin > cscol && rfin>=csrow) {
        op = 1;
        for (int i=csrow; i<=rfin; i++){
            for(int j=cscol; j<cfin; j++) {
                offs=i*cols+j;
                // UNDO stuff
                _unDo u;
                u.offs = offs;
                u.txtval = *(buf+offs);
                u.attrsval = *(attrs+offs);
                u.op = op;
                unDo.append(u);
                unDoPtr++;
                op++;
                //
                a = (uint8_t) ((ffg & 0x0f) << 4) + (bbg & 0x07);
                if (blinkwrt) a |= 8;
                *(attrs+offs) = (uint8_t) a;
                emit documentModified();
            }
        }
    }
    else {
        op = 1;
        offs=csrow*cols+cscol;
        // UNDO stuff
        _unDo u;
        u.offs = offs;
        u.txtval = *(buf+offs);
        u.attrsval = *(attrs+offs);
        u.op = op;
        unDo.append(u);
        unDoPtr++;
        //
        a = (uint8_t) ((ffg & 0x0f) << 4) + (bbg & 0x07);
        if (blinkwrt) a |= 8;
        *(attrs+offs) = (uint8_t) a;
        emit documentModified();
    }
    //repaint();
}

